// jaki¶tam sobie opis API libgadu
// (c) copyright 2001-2002 by wojtek kaniewski <wojtekka@irc.pl>
//			      robert j. wozny <speedy@ziew.org>

ka¿da sesja jest opisywana przez ,,struct gg_session''. biblioteka mo¿e
w ramach jednego procesu/w±tku obs³ugiwaæ tyle sesji, na ile pozwol±
zasoby. deklarujemy sobie...

	struct gg_session *blah;

nastêpnie wypada³oby siê po³±czyæ. przyk³ad bêdzie dotyczy³ socketów
nieblokuj±cych, bo w wiêkszo¶ci aplikacji ciê¿ko sobie pozwoliæ na
zawieszanie programu na czas ³±czenia.

	if (!(blah = gg_login(123456, "has³o", 1)))
		my_error();

parametry to numerek cz³owieczka, has³o i jedynka oznaczaj±ca, ¿e chcemy
nieblokuj±ce sockety. je¶li uda siê rozpocz±æ proces ³±czenia, dostajemy
wska¼nik do struktury, inaczej NULL. wywo³anie gg_login() powoduje
uruchomienie drugiego procesu w tle, który wywo³a gethostbyname() i przez
pipe'a zwróci wynik. pó¼niej po³±czy siê z serwerem, wy¶le, odbierze,
po³±czy siê ze wskazanym adresem IP, zaloguje siê itd. zaraz po gg_login()
mo¿emy wpisaæ ,,blah->initial_status'', czyli jaki stan ma mieæ u¿ytkownik
po zalogowaniu siê. jako ¿e wszystko dziejê siê w tle, klient musi
sprawdzaæ ca³y czas podane deskryptory. pole ,,blah->fd'' zawiera
deskryptor, a ,,blah->check'' jest bitmap± i zawiera GG_CHECK_READ i/lub
GG_CHECK_WRITE je¶li mamy sprawdziæ czy przysz³y nowe dane i/lub mo¿emy
wysy³aæ. je¶li co¶ siê wydarzy, wywo³ujemy ,,gg_watch_fd()'', a libgadu
sobie ju¿ sprawdzi, co takiego siê zdarzy³o:

	while (1) {
		fd_set rd, wr, ex;

		FD_ZERO(&rd);
		FD_ZERO(&wr);
		FD_ZERO(&ex);

		if ((blah->check & GG_CHECK_READ))
			FD_SET(blah->fd, &rd);
		if ((blah->check & GG_CHECK_WRITE))
			FD_SET(blah->fd, &wr);
		FD_SET(blah->fd, &ex);

		if (select(blah->fd + 1, &rd, &wr, &ex, NULL) == -1)
			my_error();

		if (FD_ISSET(blah->fd, &ex))
			my_error();

		if (FD_ISSET(blah->fd, &rd) || FD_ISSET(blah->fd, &wr))
			my_handle_event();
	}

nie ma tutaj obs³ugi timeoutów itp. je¶li komu¶ zale¿y, niech sobie
sam dopisze. poza tym, je¶li program sprawdza te¿ inne deskryptory
jak np. stdin dla klientów konsolowych, dobrze by³oby sprawdziæ, czy
dana sesja co¶ robi i nie sprawdzaæ ,,blah->fd'' je¶li
,,blah->state == GG_STATE_IDLE''. no i od czasu do czasu mo¿na by
dawaæ znaæ serwerowi, ¿e co¶ siê dzieje za pomoc±...

	gg_ping(blah);

ale to ju¿ wymaga implementacji jakich¶ timeoutów i liczenia czasu od
ostatniego pinga. ,,blah->last_pong'' mówi nam, kiedy serwer ostatni
raz odpowiedzia³ na pakiet ping, a ,,blah->last_event'' mówi, kiedy
dostali¶my cokolwiek ostatnio od serwera.

wracaj±c do obs³ugi deskryptorów -- je¶li klient zauwa¿y, ¿e co¶ siê
zmieni³o na podanym sockecie, powinien wywo³aæ ,,gg_watch_fd()'',
która wszystkim siê zajmie. zwraca ona wska¼nik do zaalokowanej
struktury opisuj±cej zdarzenie. po obejrzeniu nale¿y zwolniæ j± za
pomoc± ,,gg_free_event()''. w powy¿szym przyk³adzie jest wywo³ywana
funkcja ,,my_handle_event()'', która mo¿e wygl±daæ tak:

	struct gg_event *e;
	
	if (!(e = gg_watch_fd(blah)))
		my_error();

	switch (e->type) {
		case GG_EVENT_NONE:
		case GG_EVENT_PONG:
			/* olewamy */
			break;

		case GG_EVENT_CONN_SUCCESS:
			printf("po³±czono!\n");
			/* tutaj wysy³amy userlistê za pomoc± gg_notify() */
			break;

		case GG_EVENT_CONN_FAILED:
			printf("nie uda³o siê\n");
			/* powód w e->event.failure, sta³e GG_FAILURE_... */
			break;

		case GG_EVENT_MSG:
			printf("masz wiadomo¶æ!\n");
			printf("od: %d\n", e->event.msg.sender);
			printf("tre¶æ: %s\n", e->event.msg.message);
			/* e->event.msg.class mówi czy rozmowa czy wiad. */
			/* je¶li e->event.msg.sender równy 0, to mamy */
			/* wiadomo¶æ systemow± o numerze w msg.class */
			break;

		case GG_EVENT_NOTIFY:
			printf("oto ludzie, którzy siê pojawili: ");
			/* tutaj sprawdzanie tablicy e->event.notify */
			break;

		case GG_EVENT_STATUS:
			printf("kto¶ %d zmieni³ stan\n", e->event.status.uin);
			/* nowy stan w e->event.status.status */
			break;

		case GG_EVENT_ACK:
			printf("wiadomo¶æ dotar³a do %d.\n",
				e->event.ack.recipient);
			/* e->event.ack.status mówi czy dotar³a do klienta */
			/* czy le¿y na serwerze, sta³e GG_ACK_... */
			/* e->event.ack.seq to numerek wiadomo¶ci */
			break;
	}

	gg_free_event(e);

przy okazji wiadomo, co oznacza który event. czê¶æ z nich mo¿na ignorowaæ,
je¶li robi siê okrojonego klienta, np. commandline'owego wysy³aj±cego
jedn± wiadomo¶æ.

po zalogowaniu wypada³oby wys³aæ serwerowi listê u¿ytkowników, którzy nas
interesuj±. ,,gg_notify()'' przyjmuje za argument tablicê zmiennych typu
,,uin_t''. w odpowiedzi dostaniemy GG_EVENT_NOTIFY i tablicê struktur
,,struct gg_notify_reply'', je¶li kto¶ jest. po szczegó³y odsy³am do
libgadu.c, libgadu.h i ¼róde³ konsolowego klienta. je¶li dodajemy lub
usuwamy kogo¶ w trakcie dzia³ania, nale¿y skorzystaæ z ,,gg_add_notify()''
lub ,,gg_remove_notify()''.

¿eby zmieniæ stan na zajêty lub dostêpny, u¿ywamy ,,gg_change_status()''.

wysy³anie wiadomo¶ci za pomoc± ,,gg_send_message()''. parametr ,,class''
mówi, czy ma sie pojawiæ w osobnym okienku (GG_CLASS_MSG) czy w okienku
rozmowy (GG_CLASS_CHAT). funkcja zwraca numer sekwencyjny wiadomo¶ci,
którego mo¿emy u¿yæ do potwierdzenia.

biblioteka libgadu.c wymaga zdefiniowania / albo i nie WORDS_BIGENDIAN.
jest ona definiowana [albo i nie] przez skrypt configure - i jest definiowana
[#define WORDS_BIGENDIAN 1] gdy mamy maszynê bigendianow±.

je¿eli piszesz co¶ z u¿yciem glib, mo¿esz wrzuciæ co¶ takiego:

	#include <glib.h>

	#if G_BYTE_ORDER == G_BIG_ENDIAN 
	#    define WORDS_BIGENDIAN 1
	#endif

nie testowa³em, ale powinno dzia³aæ.
je¿eli za¶ nie korzystasz z glib, skryptu configure... to b±d¼ ostrze¿ony: 
bez zdefiniowania WORDS_BIGENDIAN na maszynach bigendianowych nie bêdzie 
poprawnie pracowaæ ;>

$Id$
