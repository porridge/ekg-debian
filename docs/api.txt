// jaki¶tam sobie opis API libgadu
// (c) copyright 2001-2002 by wojtek kaniewski <wojtekka@irc.pl>
//			      robert j. wozny <speedy@ziew.org>

ka¿da sesja jest opisywana przez ,,struct gg_session''. biblioteka mo¿e
w ramach jednego procesu/w±tku obs³ugiwaæ tyle sesji, na ile pozwol±
zasoby. deklarujemy sobie...

	struct gg_session *blah;

nastêpnie wypada³oby siê po³±czyæ. przyk³ad bêdzie dotyczy³ socketów
nieblokuj±cych, bo w wiêkszo¶ci aplikacji ciê¿ko sobie pozwoliæ na
zawieszanie programu na czas ³±czenia.

	struct gg_login_params p;

	memset(&p, 0, sizeof(p));
	p.uin = 123456;
	p.password = "has³o";
	p.async = 1;
	p.status = GG_STATUS_INVISIBLE;

	if (!(blah = gg_login(&p)))
		my_error();

je¶li uda siê rozpocz±æ proces ³±czenia, dostajemy wska¼nik do struktury,
inaczej NULL. wywo³anie gg_login() powoduje uruchomienie drugiego procesu
w tle, który wywo³a gethostbyname() i przez pipe'a zwróci wynik. pó¼niej
po³±czy siê z serwerem, wy¶le, odbierze, po³±czy siê ze wskazanym adresem
IP, zaloguje siê itd. jako ¿e wszystko dziejê siê w tle, klient musi
sprawdzaæ ca³y czas podane deskryptory. pole ,,blah->fd'' zawiera
deskryptor, a ,,blah->check'' jest bitmap± i zawiera GG_CHECK_READ i/lub
GG_CHECK_WRITE je¶li mamy sprawdziæ czy przysz³y nowe dane i/lub mo¿emy
wysy³aæ. je¶li co¶ siê wydarzy, wywo³ujemy ,,gg_watch_fd()'', a libgadu
sobie ju¿ sprawdzi, co takiego siê zdarzy³o:

	while (1) {
		fd_set rd, wr, ex;

		FD_ZERO(&rd);
		FD_ZERO(&wr);
		FD_ZERO(&ex);

		if ((blah->check & GG_CHECK_READ))
			FD_SET(blah->fd, &rd);
		if ((blah->check & GG_CHECK_WRITE))
			FD_SET(blah->fd, &wr);
		FD_SET(blah->fd, &ex);

		if (select(blah->fd + 1, &rd, &wr, &ex, NULL) == -1)
			my_error();

		if (FD_ISSET(blah->fd, &ex))
			my_error();

		if (FD_ISSET(blah->fd, &rd) || FD_ISSET(blah->fd, &wr))
			my_handle_event();
	}

nie ma tutaj obs³ugi timeoutów itp. je¶li komu¶ zale¿y, niech sobie
sam dopisze. poza tym, je¶li program sprawdza te¿ inne deskryptory
jak np. stdin dla klientów konsolowych, dobrze by³oby sprawdziæ, czy
dana sesja co¶ robi i nie sprawdzaæ ,,blah->fd'' je¶li
,,blah->state == GG_STATE_IDLE''. no i od czasu do czasu mo¿na by
dawaæ znaæ serwerowi, ¿e co¶ siê dzieje, za pomoc±...

	gg_ping(blah);

ale to ju¿ wymaga implementacji jakich¶ timeoutów i liczenia czasu od
ostatniego pinga. ,,blah->last_pong'' mówi nam, kiedy serwer ostatni
raz odpowiedzia³ na pakiet ping, a ,,blah->last_event'' mówi, kiedy
dostali¶my cokolwiek ostatnio od serwera.

wracaj±c do obs³ugi deskryptorów -- je¶li klient zauwa¿y, ¿e co¶ siê
zmieni³o na podanym sockecie, powinien wywo³aæ ,,gg_watch_fd()'',
która wszystkim siê zajmie. zwraca ona wska¼nik do zaalokowanej
struktury opisuj±cej zdarzenie. po obejrzeniu nale¿y zwolniæ j± za
pomoc± ,,gg_event_free()''. w powy¿szym przyk³adzie jest wywo³ywana
funkcja ,,my_handle_event()'', która mo¿e wygl±daæ tak:

	struct gg_event *e;
	
	if (!(e = gg_watch_fd(blah)))
		my_error();

	switch (e->type) {
		case GG_EVENT_NONE:
		case GG_EVENT_PONG:
			/* olewamy */
			break;

		case GG_EVENT_CONN_SUCCESS:
			printf("po³±czono!\n");
			/* tutaj wysy³amy userlistê za pomoc± gg_notify() */
			break;

		case GG_EVENT_CONN_FAILED:
			printf("nie uda³o siê\n");
			/* powód w e->event.failure, sta³e GG_FAILURE_... */
			break;

		case GG_EVENT_MSG:
			printf("masz wiadomo¶æ!\n");
			printf("od: %d\n", e->event.msg.sender);
			printf("tre¶æ: %s\n", e->event.msg.message);
			/* e->event.msg.class mówi czy rozmowa czy wiad. */
			/* je¶li e->event.msg.sender równy 0, to mamy */
			/* wiadomo¶æ systemow± o numerze w msg.class */
			break;

		case GG_EVENT_NOTIFY:
			printf("oto ludzie, którzy siê pojawili: ");
			/* tutaj sprawdzanie tablicy e->event.notify */
			break;

		case GG_EVENT_STATUS:
			printf("kto¶ %d zmieni³ stan\n", e->event.status.uin);
			/* nowy stan w e->event.status.status */
			break;

		case GG_EVENT_ACK:
			printf("wiadomo¶æ dotar³a do %d.\n",
				e->event.ack.recipient);
			/* e->event.ack.status mówi czy dotar³a do klienta */
			/* czy le¿y na serwerze, sta³e GG_ACK_... */
			/* e->event.ack.seq to numerek wiadomo¶ci */
			break;

		case GG_EVENT_SEARCH50_REPLY:
			printf("znalaz³o kogo¶\n");
			/* opisane ni¿ej */
			break;
	}

	gg_event_free(e);

przy okazji wiadomo, co oznacza który event. czê¶æ z nich mo¿na ignorowaæ,
je¶li robi siê okrojonego klienta, np. commandline'owego wysy³aj±cego
jedn± wiadomo¶æ.

po zalogowaniu wypada³oby wys³aæ serwerowi listê u¿ytkowników, którzy nas
interesuj±. ,,gg_notify()'' przyjmuje za argument tablicê zmiennych typu
,,uin_t''. w odpowiedzi dostaniemy GG_EVENT_NOTIFY i tablicê struktur
,,struct gg_notify_reply'', je¶li kto¶ jest. po szczegó³y odsy³am do
libgadu.c, libgadu.h i ¼róde³ konsolowego klienta. je¶li dodajemy lub
usuwamy kogo¶ w trakcie dzia³ania, nale¿y skorzystaæ z ,,gg_add_notify()''
lub ,,gg_remove_notify()''.

¿eby zmieniæ stan na zajêty lub dostêpny, u¿ywamy ,,gg_change_status()''.

wysy³anie wiadomo¶ci za pomoc± ,,gg_send_message()''. parametr ,,class''
mówi, czy ma sie pojawiæ w osobnym okienku (GG_CLASS_MSG) czy w okienku
rozmowy (GG_CLASS_CHAT). funkcja zwraca numer sekwencyjny wiadomo¶ci,
którego mo¿emy u¿yæ do potwierdzenia.

jedyne zale¿no¶ci libgadu w domy¶lnej wersji to <sys/types.h> i <stdint.h>



[ Date: Sat, 11 Jan 2003 20:28:54 +0100 (CET)   ]
[ From: Wojtek Kaniewski <wojtekka@dev.null.pl> ]
[ To: ekg-devel@list.ziew.org                   ]
[ Subject: [ekg-devel] wyszukiwanie w gg 5.0    ]

skoro ju¿ dzia³a, opiszê aktualne API. g³ównym za³o¿eniem by³a
maksymalna niezale¿no¶æ od zmian w protokole, zmian nazw pól, dodawania
nowych itd. zastosowane podej¶cie mo¿e byæ trochê dziwne na pierwszy rzut
oka, ale podpatrzy³em to w powa¿niejszych projektach (np. libdbi).

je¶li chcemy szukaæ:

        gg_search50_t req = gg_search50_new();

        if (!req)
                out_of_memory();

        /* szukamy po numerku... */

        gg_search50_add(req, GG_SEARCH50_UIN, "123456");

        /* lub... */

        gg_search50_add(req, GG_SEARCH50_FIRSTNAME, "Ania");
        gg_search50_add(req, GG_SEARCH50_GENDER, GG_SEARCH50_GENDER_FEMALE);

        /* lub... */

        gg_search50_add(req, GG_SEARCH50_BIRTHYEAR, "1979 1985");
        gg_search50_add(req, GG_SEARCH50_START, "0");
        gg_search50_add(req, GG_SEARCH50_ACTIVE, GG_SEARCH50_ACTIVE_TRUE);

        /* i w koñcu... */

        gg_search50(sesja, req);

        /* i zwalniamy pamiêæ, albo sobie gdzie¶ zachowujemy. whatever */

        gg_search50_free(req);

jak witaæ, gg_search50_new() tworzy obiekt opisuj±cy wyszukiwanie,
gg_search50_add() dodaje kolejne parametry. rodzaj parametru jest w
rzeczywi¶ci sta³± tekstowk±, np. GG_SEARCH50_UIN to "FmNumber". nale¿y
pamiêtaæ, ¿e wszystkie argumenty s± tekstami. nie trzeba siê bawiæ w ich
alokowanie czy co¶ takiego. biblioteka sobie sama zapamiêta. teksty musz±
byæ oczywi¶cie w CP1250. na koñcu wywo³ujemy gg_search50() i tyle. funkcja
ta zwraca numer sekwencyjny wyszukiwania, który mo¿emy sobei zachowaæ dla
pó¼niejszych referencji.

¿eby otrzymaæ wynik nale¿y obs³u¿yæ zdarzenei GG_EVENT_SEARCH50_RESULT, a
nastêpnie:

        gg_search50_t res = zdarzenie->event.search50;
        int count = gg_search50_count(res);

        if (count < 1) {
                wiadomo¶æ("Nie znaleziono");
                return;
        }

        for (int i = 0; i < count; i++) {
                const char *uin, *first, *nick, *born, *city, *status;

                uin = gg_search50_get(res, i, GG_SEARCH50_UIN);
                first = gg_search50_get(res, i, GG_SEARCH50_FIRSTNAME);
                nick = gg_search50_get(res, i, GG_SEARCH50_NICK);
                born = gg_search50_get(res, i, GG_SEARCH50_BIRTHYEAR);
                city = gg_search50_get(res, i, GG_SEARCH50_CITY);
                status = gg_search50_get(res, i, GG_SEARCH50_STATUS);

                printf("Numer: %s\nImiê: %s\nPseudonim: %s\n"
                        "Urodzony: %s\nMiejscowo¶æ: %s\n", uin,
                        first, nick, born, city);

                switch ((status) ? atoi(status) : -1) {
                        case GG_STATUS_AVAIL:
                                printf("Dostêpny\n");
                                break;
                        case GG_STATUS_BUSY:
                                printf("Zajêty\n");
                                break;
                        default:
                                printf("Niedostêpny\n");
                }

                printf("\n");
        }

        gg_event_free(zdarzenie);

je¶li chcemy wiedzieæ, od jakiego numeru zacz±c wyszukiwanie, ¿eby dostaæ
dalsz± czê¶æ, uzywamy gg_search50_next(). je¶li chcemy numer sekwencyjny,
u¿ywamy gg_search50_seq().

w ¿adnym wypadku nie mo¿na siê odwo³ywaæ do pól gg_search50_t, poniewa¿
mog± siê zmienaiæ miêdzy wersjami biblioteki. dziêki odwo³ywaniu siê przez
funkcje, mamy pewno¶æ, ¿e bez wzglêdu na zmiany API/ABI mamy to samo.
dodatkowo, je¶li dojd± jakies opcje wyszukiwania, nie trzeba w bibliotece
niczego zmieniaæ -- ¿adnych struktur, itd. po prostu odwo³ujemy siê do
kolejnego pola przez gg_search50_add() i gg_search50_get().

w przysz³o¶ci tak samo chcia³bym rozwi±zaæ parametry gg_login(), ale to
inny historia.

teraz pytanie: czy dru¿yna pier¶c^W Kadu ma jakie¶ uwagi, komentarze itp?
jestem otwarty na propozycje, je¶li jaka¶ zmiana mia³aby u³atwiæ Wam ¿ycie
(mi mo¿e utrudniæ, byle w granicach rozs±dku ;>)

pozdr,
w.




$Id$
