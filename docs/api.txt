// szybki kurs libgadu
// (c) copyright 2001-2003 by wojtek kaniewski <wojtekka@irc.pl>
//			      robert j. wozny <speedy@ziew.org>

// tekst poprawiany ostatnio 2003-03-11

ka¿da sesja jest opisywana przez ,,struct gg_session''. biblioteka mo¿e
w ramach jednego procesu/w±tku obs³ugiwaæ tyle sesji, na ile pozwol±
zasoby. na pocz±tku deklarujemy:

	struct gg_session *blah;

nastêpnie bêdziemy siê ³±czyæ. przyk³ad bêdzie dotyczy³ socketów
nieblokuj±cych, bo w wiêkszo¶ci aplikacji ciê¿ko sobie pozwoliæ na
zawieszanie programu na czas ³±czenia.

	struct gg_login_params p;

	memset(&p, 0, sizeof(p));
	p.uin = 123456;
	p.password = "has³o";
	p.async = 1;
	p.status = GG_STATUS_INVISIBLE;

	if (!(blah = gg_login(&p)))
		my_error();

je¶li uda siê rozpocz±æ proces ³±czenia, dostajemy wska¼nik do struktury,
inaczej NULL. wywo³anie gg_login() powoduje uruchomienie drugiego procesu
lub w±tku w tle, który wywo³a gethostbyname() i potokiem zwróci wynik.
pó¼niej po³±czy siê z serwerem, wy¶le, odbierze, po³±czy siê ze wskazanym
adresem IP, zaloguje siê itd. jako ¿e wszystko dziejê siê w tle, klient
musi sprawdzaæ ca³y czas podane deskryptory. pole ,,blah->fd'' zawiera
deskryptor, a ,,blah->check'' jest bitmap± i zawiera GG_CHECK_READ i/lub
GG_CHECK_WRITE je¶li mamy sprawdziæ czy przysz³y nowe dane i/lub mo¿emy
wysy³aæ. je¶li co¶ siê wydarzy, wywo³ujemy ,,gg_watch_fd()'', a libgadu
sobie ju¿ sprawdzi, co takiego siê zdarzy³o:

	while (1) {
		fd_set rd, wr, ex;

		FD_ZERO(&rd);
		FD_ZERO(&wr);
		FD_ZERO(&ex);

		if ((blah->check & GG_CHECK_READ))
			FD_SET(blah->fd, &rd);
		if ((blah->check & GG_CHECK_WRITE))
			FD_SET(blah->fd, &wr);
		FD_SET(blah->fd, &ex);

		if (select(blah->fd + 1, &rd, &wr, &ex, NULL) == -1)
			my_error();

		if (FD_ISSET(blah->fd, &ex))
			my_error();

		if (FD_ISSET(blah->fd, &rd) || FD_ISSET(blah->fd, &wr))
			my_handle_event();
	}

dla uproszczenia, nie ma tutaj obs³ugi timeoutów i tym podobnych dodatków.
poza tym, je¶li program sprawdza te¿ inne deskryptory (np. stdin dla
klientów konsolowych), dobrze by³oby sprawdziæ, czy dana sesja co¶ robi i
nie sprawdzaæ ,,blah->fd'' je¶li ,,blah->state == GG_STATE_IDLE''. od czasu
do czasu mo¿na daæ serwerowi znaæ, ¿e co¶ siê dzieje, za pomoc±...

	gg_ping(blah);

ale to ju¿ wymaga implementacji timerów i liczenia czasu od ostatniego
pinga. ,,blah->last_event'' mówi, kiedy dostali¶my cokolwiek ostatnio od
serwera. wszystkie pola struktury s± opisane w pliku libgadu.h.

wracaj±c do obs³ugi deskryptorów -- je¶li klient zauwa¿y, ¿e co¶ siê
zmieni³o na podanym sockecie, powinien wywo³aæ ,,gg_watch_fd()'',
która wszystkim siê zajmie. zwraca ona wska¼nik do zaalokowanej
struktury opisuj±cej zdarzenie. po obejrzeniu nale¿y zwolniæ j± za
pomoc± ,,gg_event_free()''. w powy¿szym przyk³adzie jest wywo³ywana
funkcja ,,my_handle_event()'', która mo¿e wygl±daæ tak:

	struct gg_event *e;
	
	if (!(e = gg_watch_fd(blah)))
		my_error();

	switch (e->type) {
		case GG_EVENT_NONE:
		case GG_EVENT_PONG:
			/* olewamy */
			break;

		case GG_EVENT_CONN_SUCCESS:
			printf("po³±czono!\n");
			/* tutaj wysy³amy userlistê za pomoc± gg_notify() */
			break;

		case GG_EVENT_CONN_FAILED:
			printf("nie uda³o siê\n");
			/* powód w e->event.failure, sta³e GG_FAILURE_... */
			break;

		case GG_EVENT_MSG:
			printf("masz wiadomo¶æ!\n");
			printf("od: %d\n", e->event.msg.sender);
			printf("tre¶æ: %s\n", e->event.msg.message);
			/* e->event.msg.class mówi czy rozmowa czy wiad. */
			/* je¶li e->event.msg.sender równy 0, to mamy */
			/* wiadomo¶æ systemow± o numerze w msg.class */
			break;

		case GG_EVENT_NOTIFY:
			printf("oto ludzie, którzy siê pojawili: ");
			/* tutaj sprawdzanie tablicy e->event.notify */
			break;

		case GG_EVENT_STATUS:
			printf("kto¶ %d zmieni³ stan\n", e->event.status.uin);
			/* nowy stan w e->event.status.status */
			break;

		case GG_EVENT_ACK:
			printf("wiadomo¶æ dotar³a do %d.\n",
				e->event.ack.recipient);
			/* e->event.ack.status mówi czy dotar³a do klienta */
			/* czy le¿y na serwerze, sta³e GG_ACK_... */
			/* e->event.ack.seq to numerek wiadomo¶ci */
			break;

		case GG_EVENT_PUBDIR50_REPLY:
			printf("znalaz³o kogo¶\n");
			/* opisane ni¿ej */
			break;
	}

	gg_event_free(e);

przy okazji wiadomo, co oznaczaj± zdarzenia. czê¶æ z nich mo¿na ignorowaæ,
je¶li robi siê okrojonego klienta, np. wysy³aj±cego jedn± wiadomo¶æ z linii
komend.

po zalogowaniu nale¿y wys³aæ serwerowi listê u¿ytkowników, których mamy
w li¶cie kontaktów. ,,gg_notify()'' przyjmuje za argument tablicê zmiennych
typu ,,uin_t''. w odpowiedzi dostaniemy GG_EVENT_NOTIFY i tablicê struktur
,,struct gg_notify_reply'', je¶li kto¶ jest. po szczegó³y odsy³am do
libgadu.c, libgadu.h i ¼róde³ konsolowego klienta. je¶li dodajemy lub
usuwamy kogo¶ w trakcie dzia³ania, nale¿y skorzystaæ z ,,gg_add_notify()''
lub ,,gg_remove_notify()''. je¶li chcemy korzystaæ z listy osób blokowanych
lub takich, przed którymi siê ukrywamy, nale¿y korzystaæ z funkcji
,,gg_notify_ex()'', ,,gg_add_notify_ex()'' i ,,gg_remove_notify_ex()'',
które bior± dodatkowy argument mówi±cy, jak traktowaæ u¿ytkownika.
odpowiadaj± za to sta³e GG_USER_NORMAL, GG_USER_BLOCKED i GG_USER_OFFLINE.

¿eby zmieniæ stan na zajêty lub dostêpny, u¿ywamy ,,gg_change_status()'',
,,gg_change_status_descr()'' lub ,,gg_change_status_descr_time()''.

wysy³anie wiadomo¶ci za pomoc± ,,gg_send_message()''. parametr ,,class''
mówi, czy ma sie pojawiæ w osobnym okienku (GG_CLASS_MSG) czy w okienku
rozmowy (GG_CLASS_CHAT). funkcja zwraca numer sekwencyjny wiadomo¶ci,
którego mo¿emy u¿yæ do potwierdzenia. wiadomo¶æ, która ma byæ sformatowana
w odpowiedni sposób (pogrubienie, kursywa, kolory, itp.) wysy³amy za pomoc±
,,gg_send_message_richtext()''. wiadomo¶ci konferencyjne wysy³amy funkcjami
,,gg_send_message_confer()'' lub ,,gg_send_message_confer_richtext()''.

je¶li chcemy siê wylogowaæ, wywo³ujemy ,,gg_logoff()'' i potem zwalniamy
pamiêæ zwi±zan± z sesj± funkcj± ,,gg_free_session()''.

je¶li chcemy przypomnieæ swoje has³o, wywo³ujemy funkcjê
,,gg_remind_password2()'', a wynikow± struktujê ,,gg_http'' traktujemy
podobnie do ,,gg_session'':
 - sprawdzamy ->fd i ->check,
 - wywo³ujemy ,,gg_remind_passwd_watch_fd()'', gdy co¶ siê dzieje. funkcja
   ta zwraca -1 w przypadku b³êdu. je¶li zwraca 0, wywo³ujemy j±, póki
   ->state nie bêdzie równe GG_STATE_DONE lub GG_STATE_ERROR.
 - po zakoñczeniu, wywo³ujemy ,,gg_remind_passwd_free()''.

je¶li chcemy zmieniæ has³o, wywo³ujemy funkcjê ,,gg_change_passwd3()''
i traktujemy podobnie wynikowe ,,gg_http''.

do zarz±dzania list± kontaktów na serwerze s³u¿± funkcje
,,gg_userlist_get()'', ,,gg_userlsit_put()'' i ,,gg_userlist_remove()''.

***

OBS£UGA KATALOGU PUBLICZNEGO GG 5.0 (na podstawie listu na ekg-devel)

skoro ju¿ dzia³a, opiszê aktualne API. g³ównym za³o¿eniem by³a
maksymalna niezale¿no¶æ od zmian w protokole, zmian nazw pól, dodawania
nowych itd. zastosowane podej¶cie mo¿e byæ trochê dziwne na pierwszy rzut
oka, ale podpatrzy³em to w powa¿niejszych projektach (np. libdbi).

je¶li chcemy szukaæ:

        gg_pubdir50_t req = gg_pubdir50_new(GG_PUBDIR50_SEARCH_REQUEST);

        if (!req)
                out_of_memory();

        /* szukamy po numerku... */

        gg_pubdir50_add(req, GG_PUBDIR50_UIN, "123456");

        /* lub... */

        gg_pubdir50_add(req, GG_PUBDIR50_FIRSTNAME, "Ania");
        gg_pubdir50_add(req, GG_PUBDIR50_GENDER, GG_PUBDIR50_GENDER_FEMALE);

        /* lub... */

        gg_pubdir50_add(req, GG_PUBDIR50_BIRTHYEAR, "1979 1985");
        gg_pubdir50_add(req, GG_PUBDIR50_START, "0");
        gg_pubdir50_add(req, GG_PUBDIR50_ACTIVE, GG_PUBDIR50_ACTIVE_TRUE);

        /* i w koñcu... */

        gg_pubdir50(sesja, req);

        /* i zwalniamy pamiêæ, albo sobie gdzie¶ zachowujemy. whatever */

        gg_pubdir50_free(req);

jak witaæ, gg_pubdir50_new() tworzy obiekt opisuj±cy operacjê katalogu,
gg_pubdir50_add() dodaje kolejne parametry. rodzaj parametru jest w
rzeczywi¶ci sta³± tekstow±, np. GG_PUBDIR50_UIN to "FmNumber". nale¿y
pamiêtaæ, ¿e wszystkie argumenty s± tekstami. nie trzeba siê bawiæ w ich
alokowanie czy co¶ takiego. biblioteka sobie sama zapamiêta. teksty musz±
byæ oczywi¶cie w CP1250. na koñcu wywo³ujemy gg_pubdir50() i tyle. funkcja
ta zwraca numer sekwencyjny wyszukiwania, który mo¿emy sobie zachowaæ dla
pó¼niejszych referencji.

¿eby otrzymaæ wynik, nale¿y obs³u¿yæ zdarzenia GG_EVENT_PUBDIR50_SEARCH_REPLY,
GG_EVENT_PUBDIR50_WRITE i GG_EVENT_PUBDIR50_READ. dla przyk³adu, obs³uga
wyników wyszukiwania wygl±da nastêpuj±co:

        gg_search50_t res = zdarzenie->event.search50;
        int count = gg_search50_count(res);

        if (count < 1) {
                wiadomo¶æ("Nie znaleziono");
                return;
        }

        for (int i = 0; i < count; i++) {
                const char *uin, *first, *nick, *born, *city, *status;

                uin = gg_pubdir50_get(res, i, GG_PUBDIR50_UIN);
                first = gg_pubdir50_get(res, i, GG_PUBDIR50_FIRSTNAME);
                nick = gg_pubdir50_get(res, i, GG_PUBDIR50_NICK);
                born = gg_pubdir50_get(res, i, GG_PUBDIR50_BIRTHYEAR);
                city = gg_pubdir50_get(res, i, GG_PUBDIR50_CITY);
                status = gg_pubdir50_get(res, i, GG_PUBDIR50_STATUS);

                printf("Numer: %s\nImiê: %s\nPseudonim: %s\n"
                        "Urodzony: %s\nMiejscowo¶æ: %s\n", uin,
                        first, nick, born, city);

/*
  status w wynikach wyszukiwania w przypadku ,,tylko dla znajomych''
  jest oznaczony innym bitem ni¿ GG_STATUS_FRIENDS_MASK.
 */
#define GG_SEARCH_FRIENDS_MASK	0x0080

                switch ((status) ? (atoi(status) & ~GG_SEARCH_FRIENDS_MASK) : -1) {
                        case GG_STATUS_AVAIL:
                                printf("Dostêpny\n");
                                break;
                        case GG_STATUS_BUSY:
                                printf("Zajêty\n");
                                break;
                        default:
                                printf("Niedostêpny\n");
                }

                printf("\n");
        }

        gg_event_free(zdarzenie);

je¶li chcemy wiedzieæ, od jakiego numeru zacz±c wyszukiwanie, ¿eby dostaæ
dalsz± czê¶æ, uzywamy gg_pubdir50_next(). je¶li chcemy numer sekwencyjny,
u¿ywamy gg_pubdir50_seq().

w ¿adnym wypadku nie mo¿na siê odwo³ywaæ do pól gg_pubdir50_t, poniewa¿
mog± siê zmieniaæ miêdzy wersjami biblioteki. dziêki odwo³ywaniu siê przez
funkcje, mamy pewno¶æ, ¿e bez wzglêdu na zmiany API/ABI mamy to samo.
dodatkowo, je¶li dojd± jakies opcje wyszukiwania, nie trzeba w bibliotece
niczego zmieniaæ -- ¿adnych struktur, itd. po prostu odwo³ujemy siê do
kolejnego pola przez gg_pubdir50_add() i gg_pubdir50_get().


$Id$
