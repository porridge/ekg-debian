<!-- (C) Copyright 2001-2002 by ekg team -->
<html>
<head>
<meta http-equiv="Content-type" content="text/html; charset=iso-8859-2">
</head>
<body bgcolor=white text=black>

<center>
<table width=600><tr><td>

<center>
<h1>Protokó³ Gadu-Gadu</h1>
<h3>&copy; Copyright 2001, 2002 <a href="#ch4">Autorzy</a></h3>
</center>

<hr>
<h2>0. Informacje wstêpne</h2>
<p>
Opis protoko³u u¿ywanego przez Gadu-Gadu bazuje na do¶wiadczeniach
przeprowadzonych przez autorów oraz informacjach nadsy³anych przez 
u¿ytkowników. ¯aden klient Gadu-Gadu nie zosta³ skrzywdzony podczas
badañ. Reverse-engineering opiera³ siê g³ównie na analizie pakietów
wysy³anych miêdzy klientem a serwerem.
</p>

<hr>
<h2>1. Protokó³ Gadu-Gadu</h2>

<h3>1.1. Format pakietów</h3>
<p>
Podobnie jak coraz wiêksza ilo¶æ komunikatorów, Gadu-Gadu korzysta z
protoko³u TCP/IP. Ka¿dy pakiet zawiera na pocz±tku dwa sta³e pola:
</p>
<p><pre>
        struct gg_header {
		int type;	<i>/* typ pakietu */</i>
		int length;	<i>/* d³ugo¶æ reszty pakietu */</i>
	};
</pre></p>
<p>
Wszystkie zmienne liczbowe s± zgodne z kolejno¶ci± bajtów maszyn Intela,
czyli Little-Endian.
</p>
<p>
Przy opisie struktur, za³o¿ono, ¿e <tt>char</tt> ma rozmiar 1 bajtu,
<tt>short</tt> 2 bajtów, <tt>int</tt> 4 bajtów. U¿ywaj±c innych
architektur ni¿ i386 nale¿y zwróciæ szczególn± uwagê na rozmiar typów
zmiennych i kolejno¶æ znaków.
</p>
<p>
Pola, który znaczenie jest nieznane, lub nie do koñca jasne, oznaczono
przedrostkiem <tt>unknown</tt>.
</p>

<hr>
<h3>1.2. Zanim siê po³±czymy</h3>
<p>
¯eby wiedzieæ, z jakim serwerem mamy siê po³±czyæ, nale¿y poudawaæ przez
chwilê przegl±darkê WWW i po³±czyæ siê z hostem <tt>appmsg.gadu-gadu.pl</tt>.
<p><p><pre>
	GET /appsvc/appmsg.asp?fmnumber=<b>NUMER</b> HTTP/1.0
	Host: appmsg.gadu-gadu.pl
	User-Agent: Mozilla/4.7 [en] (Win98; I)
	Pragma: no-cache
</pre></p>
Oryginalny klient mo¿e wys³aæ jeden z podanych identyfikatorów przegl±darki:
<p><p><pre>
	Mozilla/4.04 [en] (Win95; I ;Nav)
	Mozilla/4.7 [en] (Win98; I)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows NT)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt)
	Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)
</pre></p>
Nowsze wersje (od 4.8.9) korzystaj± z innego skryptu:
<p><p><pre>
	GET /appsvc/appmsg2.asp?fmnumber=<b>NUMER</b>&amp;version=<b>WERSJA</b>&amp;fmt=<b>FORMAT</b>&amp;lastmsg=<b>WIADOMO¦Æ</b>
	Host: appmsg.gadu-gadu.pl
	User-Agent: ...
	Pragma: no-cache
</pre></p>
Gdzie <b>NUMER</b> jest numerem klienta, <b>WERSJA</b> jest wersj± klienta,
<b>FORMAT</b> okre¶la czy wiadomo¶æ systemowa bêdzie przesy³ana czystym
tekstem (warto¶æ "0") czy w HTMLu (warto¶æ "1"), a <b>WIADOMO¦Æ</b> jest
numerem ostatnio otrzymanej wiadomo¶ci systemowej. Na postawione
w ten sposób zapytanie, serwer powinien odpowiedzieæ:
<p><p><pre>
	HTTP/1.0 200 OK
	
	124 1 0 217.17.33.21:8074 0.0.0.0
</pre></p>
Pierwsze pole jest numerem wiadomo¶ci systemowej, drugie nie jest znane
(mo¿liwe, ¿e to ilo¶æ linii w odpowiedzi, ale wiadomo¶ci systemowe
niestety rzadko mo¿na zaobserwowaæ w przyrodzie), a trzecie okre¶la czy
odpowied¼ zawiera wiadomo¶æ systemow±. Czwarte pole jest adresem serwera,
z którym klient powinien siê ³±czyæ. Je¿eli po³±czenie z portem 8074 nie
wyjdzie z jaki¶ powodów, mo¿na siê ³±czyæ na port 443. 

<hr>
<h3>1.3. Logowanie siê</h3>
<p>
Po po³±czeniu siê portem 8074 lub 443 serwera Gadu-Gadu, dostajemy pakiet
typu <tt>0x0001</tt>, który na potrzeby tego dokumentu nazwiemy:
<p><p><pre>
	#define GG_WELCOME 0x0001
</pre></p>
Reszta pakietu zawiera liczbê, na podstawie której liczony jest hash z has³a
klienta:
<p><p><pre>
	struct gg_welcome {
		int seed;	<i>/* klucz szyfrowania has³a */</i>
	};
</pre></p>	
Kiedy mamy ju¿ t± warto¶æ mo¿emy odes³aæ pakiet logowania
<p><p><pre>
	#define GG_LOGIN 0x000c
</pre></p>
Musimy podaæ kilka informacji:
<p><p><pre>
	struct gg_login {
		int uin;		<i>/* numer klienta */</i>
		int hash;		<i>/* hash has³a */</i>
		int status;		<i>/* pocz±tkowy stan */</i>
		int version;		<i>/* wersja klienta */</i>
		int local_ip;		<i>/* mój adres ip */</i>
		short local_port;	<i>/* port, na którym s³ucham */</i>
	};
</pre></p>
Hash has³a w pierwszych wersjach by³ liczony w do¶æ prosty sposób, ale
niestety z któr±¶ zmian± protoko³u wprowadzono nowy algorytm:
<p><p><pre>
	int gg_login_hash(char *password, int seed)
	{
		unsigned int x, y, z;

		y = seed;

		for (x = 0; *password; password++) {
			x = (x &amp; 0xffffff00) | *password;
			y ^= x;
			y += x;
			x &lt;&lt;= 8;
			y ^= x;
			x &lt;&lt;= 8;
			y -= x;
			x &lt;&lt;= 8;
			y ^= x;

			z = y &amp; 0x1f;
			y = (y &lt;&lt; z) | (y &gt;&gt; (32 - z));
		}

		return y;
	}
</pre></p>
Liczba oznaczaj±ca wersjê mo¿e byæ jedn± z poni¿szych:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Warto¶æ<b></td><td><b>Wersje klientów</b></td></tr>
<tr><td><tt>0x16</tt></td><td>4.9.1</td></tr>
<tr><td><tt>0x15</tt></td><td>4.8.9</td></tr>
<tr><td><tt>0x14</tt></td><td>4.8.3, 4.8.1</td></tr>
<tr><td><tt>0x11</tt></td><td>4.6.10, 4.6.1</td></tr>
<tr><td><tt>0x10</tt></td><td>4.5.22, 4.5.21, 4.5.19, 4.5.17, 4.5.15</td></tr>
<tr><td><tt>0x0f</tt></td><td>4.5.12</td></tr>
<tr><td><tt>0x0b</tt></td><td>4.0.30, 4.0.29, 4.0.28, 4.0.25</td></tr>
</table></center>
<p>
Oczywi¶cie nie s± to wszystkie mo¿liwe wersje klientów, lecz te, które
uda³o siê z³apaæ na wolno¶ci. Najbezpieczniej bêdzie przedstawiaæ siê jako
ta wersja, której w³asno¶ci u¿ywamy. Wiadomo, ¿e wersje 4.0 nie obs³ugiwa³y
trybu ukrytego, tylko dla znajomych itd. 
<p>
Je¶li wszystko siê powiedzie, dostaniemy w odpowiedzi pakiet typu:
<p><p><pre>
	#define GG_LOGIN_OK 0x0003
</pre></p>
o zerowej d³ugo¶ci, lub w przypadku b³êdu pakiet:
<p><p><pre>
	#define GG_LOGIN_FAILED 0x0009
</pre></p>

<hr>
<h3>1.4. Zmiana stanu</h3>
<p>
Gadu-Gadu przewiduje kilka stanów klienta, które zmieniamy pakietem typu:
<p><p><pre>
	#define GG_NEW_STATUS 0x0002

	struct gg_new_status {
		int status;		<i>/* na jaki zmieniæ? */</i>
		char description[];	<i>/* opis, nie musi wyst±piæ */</i>
	}
</pre></p>
Mo¿liwe stany to:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr><td><tt>GG_STATUS_NOT_AVAIL</tt></td><td><tt>0x0001</tt></td><td>Niedostêpny</td></tr>
<tr><td><tt>GG_STATUS_NOT_AVAIL_DESCR</tt></td><td><tt>0x0015</tt></td><td>Niedostêpny (z opisem)</td></tr>
<tr><td><tt>GG_STATUS_AVAIL</tt></td><td><tt>0x0002</tt></td><td>Dostêpny</td></tr>
<tr><td><tt>GG_STATUS_AVAIL_DESCR</tt></td><td><tt>0x0004</tt></td><td>Dostêpny (z opisem)</td></tr>
<tr><td><tt>GG_STATUS_BUSY</tt></td><td><tt>0x0003</tt></td><td>Zajêty</td></tr>
<tr><td><tt>GG_STATUS_BUSY_DESCR</tt></td><td><tt>0x0005</tt></td><td>Zajêty (z opisem)</td></tr>
<tr><td><tt>GG_STATUS_INVISIBLE</tt></td><td><tt>0x0014</tt></td><td>Niewidoczny</td></tr>
<tr><td><tt>GG_STATUS_INVISIBLE_DESCR</tt></td><td><tt>0x0016</tt></td><td>Niewidoczny z opisem</td></tr>
<tr><td><tt>GG_STATUS_BLOCKED</tt></td><td><tt>0x0006</tt></td><td>Zablokowany</td></tr>
<tr><td><tt>GG_STATUS_FRIENDS_MASK</tt></td><td><tt>0x8000</tt></td><td>Maska bitowa oznaczaj±ca tryb tylko dla przyjació³</td></tr>
</table></center>
<p>
Nale¿y pamiêtaæ, ¿eby przed roz³±czeniem siê z serwerem nale¿y zmieniæ
stan na <tt>GG_STATUS_NOT_AVAIL</tt> lub <tt>GG_STATUS_NOT_AVAIL_DESCR</tt>.
Je¶li ma byæ widoczny tylko dla przyjació³, nale¿y dodaæ
<tt>GG_STATUS_FRIENDS_MASK</tt> do normalnej warto¶ci stanu. Je¶li wybieramy
stan z opisem, nale¿y do³±czyæ do struktury ci±g znaków niezakoñczony zerem.

<hr>
<h3>1.5. Ludzie przychodz±, ludzie odchodz±</h3>
<p>
Zaraz po zalogowaniu mo¿emy wys³aæ serwerowi nasz± listê kontaktów, ¿eby
dowiedzieæ siê, czy s± w danej chwili dostêpni. Pakiet zawiera dowoln±
ilo¶æ struktur <tt>gg_notify</tt>:
<p><pre>
	#define GG_NOTIFY 0x0010
	
	struct gg_notify {
		int uin;	<i>/* numerek danej osoby */</i>
		char type;	<i>/* rodzaj u¿ytkownika */</i>
	};
</pre></p>	
Gdzie pole <tt>type</tt> przyjmuje nastêpuj±ce warto¶ci:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr><td><tt>GG_USER_NORMAL</tt></td><td><tt>0x03</tt></td><td>Zwyk³y u¿ytkownik dodany do listy kontkatów</td></tr>
<tr><td><tt>GG_USER_BLOCKED</tt></td><td><tt>0x04</tt></td><td>U¿ytkownik, którego wiadomo¶ci nie chcemy otrzymywaæ</td></tr>
</table></center>

<!-- Adam pisa³, ¿e jest to bitmapa, w której 0x01 znaczy otwarte okienko
rozmowy z dan± osob±, ale wygl±da³oby to co najmniej dziwnie, wiêc
upro¶ci³em trochê ca³± sprawê. -->

<p>
Je¶li kto¶ jest, serwer odpowie pakietem zawieraj±cym jedn± lub wiêcej
struktur <tt>gg_notify_reply</tt>:
<p><p><pre>
	#define GG_NOTIFY_REPLY 0x000c	/* tak, to samo co GG_LOGIN */
	
	struct gg_notify_reply {
		int uin;		/* numerek */
		int status;		/* status danej osoby */
		int remote_ip;		/* adres ip delikwenta */
		short remote_port;	/* port, na którym s³ucha klient */
		int version;		/* wersja klienta */
		short unknown1;		/* znowu port? */
		char description[];	/* opis, nie musi wyst±piæ */
	};
</pre></p>
Wiêkszo¶æ pól powinna byæ zrozumia³a. <tt>remote_port</tt> poza zwyk³ym
portem mo¿e przyjmowaæ równie¿ poni¿sze warto¶ci:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr><td>0</td><td>Klient nie obs³uguje bezpo¶rednich po³±czeñ</td></tr>
<tr><td>1</td><td>Klient ³±czy siê zza NAT lub innej formy maskarady</td></tr>
<tr><td>2</td><td>Klient nie ma nas w swojej li¶cie kontaktów</td></tr>
</table></center>
<p>
Zdarzaj± siê te¿ inne ,,nietypowe'' warto¶ci, ale ich znaczenie nie jest
jeszcze do koñca znane.
<p>
Je¶li dany klient jest w stanie z podanym opisem, najpierw dostaniemy
informacjê osobnym pakietem o nim, pó¼niej paczkê struktur
<tt>gg_notify_reply</tt> z lud¼mi, którzy nie maj± ustawionych opisów.
<p>
¯eby dodaæ kogo¶ do listy w trakcie pracy, trzeba wys³aæ ni¿ej opisany
pakiet. Jego format jest identyczny jak przy <tt>GG_NOTIFY</tt>.
<p><p><pre>
	#define GG_ADD_NOTIFY 0x000d
	
	struct gg_add {
		int uin;	<i>/* numerek */</i>
		char type;	<i>/* rodzaj u¿ytkownika */</i>
	};
</pre></p>
By usun±æ z listy kontaktów, wysy³a siê podobny pakiet:
<p><p><pre>
	#define GG_REMOVE_NOTIFY 0x000e
	
	struct gg_add {
		int uin;	<i>/* numerek */</i>
		char type;	<i>/* rodzaj u¿ytkownika */</i>
	};
</pre></p>
Je¶li kto¶ opu¶ci Gadu-Gadu lub zmieni stan, otrzymamy pakiet:
<p><p><pre>
	#define GG_STATUS 0x0002
	
	struct gg_status {
		int uin;	<i>/* numerek */</i>
		int status;	<i>/* nowy stan */</i>
	};
</pre></p>

<hr>
<h3>1.6. Wysy³anie wiadomo¶ci</h3>
<p>
Wiadomo¶ci wysy³a siê nastêpuj±cym typem pakietu:
<p><p><pre>
	#define GG_SEND_MSG 0x000b

	struct gg_send_msg {
		int recipient;		<i>/* numer odbiorcy */</i>
		int seq;		<i>/* numer sekwencyjny */</i>
		int class;		<i>/* klasa wiadomo¶ci */</i>
		char message[];		<i>/* tre¶æ */</i>
	};
</pre></p>
Numer sekwencyjny jest wykorzystywany przy potwierdzeniu dostarczenia
lub zakolejkowania pakietu. Nie jest wykluczone, ¿e w jakis sposób odró¿nia
siê ró¿ne rozmowy za pomoc± czê¶ci bajtów, ale raczej nie powinno mieæ to
ma znaczenia. Klasa wiadomo¶ci pozwala odró¿niæ, czy wiadomo¶æ ma siê
pojawiæ w osobnym okienku czy jako kolejna linijka w okienku rozmowy. Jest
to mapa bitowa, wiêc najlepiej ignorowaæ te bity, których znaczenia nie
znamy:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr><td><tt>GG_CLASS_QUEUED</tt></td><td><tt>0x0001</tt></td><td>Bit ustawiany wy³±cznie przy odbiorze wiadomo¶ci, gdy wiadomo¶æ zosta³a wcze¶niej zakolejkowania z powodu nieobecno¶ci</td></tr>
<tr><td><tt>GG_CLASS_MSG</tt></td><td><tt>0x0004</tt></td><td>Wiadomo¶æ ma siê pojawiæ w osobnym okienku</td></tr>
<tr><td><tt>GG_CLASS_CHAT</tt></td><td><tt>0x0008</tt></td><td>Wiadomo¶æ jest czê¶ci± tocz±cej siê rozmowy i zostanie wy¶wietlona w istniej±cym okienku</td></tr>
<tr><td><tt>GG_CLASS_CTCP</tt></td><td><tt>0x0010</tt></td><td>Wiadomo¶æ jest przeznaczona dla klienta Gadu-Gadu i nie powinna byæ wy¶wietlona u¿ytkownikowi.</td></tr>
<tr><td><tt>GG_CLASS_UNKNOWN_1</tt></td><td><tt>0x0020</tt></td><td>Bit o nieznanym znaczeniu, lecz wystêpuj±cy do¶æ czêsto w naturalnych warunkach.</td></tr>
</table></center>
<p>
D³ugo¶æ tre¶ci wiadomo¶ci nie powinna przekraczaæ 2000 znaków.
<p>
Oryginalny klient wysy³aj±c wiadomo¶æ do kilku u¿ytkowników, wysy³a po
kilka takich samych pakietów z ró¿nymi numerkami odbiorców. Nie ma osobnego
pakietu do tego. Natomiast je¶li chodzi o <i>po³±czenia konferencyjne</i>
do pakietu doklejana jest nastêpuj±ca struktura:
<p><p><pre>
	struct gg_msg_recipients {
		char flag;		<i>/* == 1 */</i>
		int count;		<i>/* ilo¶æ odbiorców */</i>
		int recipients[];	<i>/* tablica odbiorców */</i>
	};
</pre></p>
Na przyk³ad, by wys³aæ do dwóch osób, nale¿y wys³aæ pakiet:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Offset</b></td><td><b>Warto¶æ</b></td></tr>
<tr><td><i>n</i></td><td>Tre¶æ wiadomo¶ci</td></tr>
<tr><td><i>m</i></td><td><tt>0x01</tt></td></tr>
<tr><td><i>m</i> + 1</td><td rowspan=4><tt>0x02</tt></td></tr>
<tr><td><i>m</i> + 2</td></tr>
<tr><td><i>m</i> + 3</td></tr>
<tr><td><i>m</i> + 4</td></tr>
<tr><td><i>m</i> + 5</td><td rowspan=4>Numer pierwszego adresata</td></tr>
<tr><td><i>m</i> + 6</td></tr>
<tr><td><i>m</i> + 7</td></tr>
<tr><td><i>m</i> + 8</td></tr>
<tr><td><i>m</i> + 9</td><td rowspan=4>Numer drugiego adresata</td></tr>
<tr><td><i>m</i> + 10</td></tr>
<tr><td><i>m</i> + 11</td></tr>
<tr><td><i>m</i> + 12</td></tr>
</table></center>
<p>
Od wersji 4.8.1 mo¿liwe jest równie¿ dodawanie do wiadomo¶ci ró¿nych
atrybutów tekstu jak pogrubienie czy kolory. Niezbêdne jest do³±czenie
nastêpnuj±cej struktury:
<p><p><pre>
	struct gg_msg_richtext {
		char flag;	<i>/* == 2 */</i>
		short length;	<i>/* d³ugo¶æ dalszej czê¶ci */</i>
	};
</pre></p>
Dalsza czê¶æ pakietu zawiera odpowiedni± ilo¶æ struktur o ³±czej d³ugo¶ci
okre¶lonej polem <tt>length</tt>:
<p><p><pre>
	struct gg_msg_richtext_format {
		short position;	<i>/* pozycja atrybutu w tek¶cie */</i>
		char font;	<i>/* atrybuty czcionki */</i>
		char rgb[3];	<i>/* kolor czcionki, nie musi wyst±piæ */</i>
	};
</pre></p>
Ka¿da z tych struktur okre¶la kawa³ek tekstu pocz±wszy od znaku okre¶lonego
przez pole <tt>position</tt> (liczone od zera) a¿ do nastêpnego wpisu lub
koñca tekstu. Pole <tt>font</tt> jest map± bitow± i kolejne bity maj±
nastêpuj±ce znaczenie:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr><td><tt>GG_FONT_BOLD</tt></td><td><tt>0x01</tt></td><td>Pogrubiony tekst</td></tr>
<tr><td><tt>GG_FONT_ITALIC</tt></td><td><tt>0x02</tt></td><td>Kursywa</td></tr>
<tr><td><tt>GG_FONT_UNDERLINE</tt></td><td><tt>0x04</tt></td><td>Podkre¶lenie</td></tr>
<tr><td><tt>GG_FONT_COLOR</tt></td><td><tt>0x08</tt></td><td>Kolorowy tekst. Tylko w tym wypadku struktura <tt>gg_msg_richtext_format</tt> zawiera pole <tt>rgb[]</tt> bêd±ce opisem trzech sk³adowych koloru, kolejno czerwonej, zielonej i niebieskiej.</td></tr>
</table></center>
<p>
Dla przyk³adu, by przes³aæ tekst ,,ala <b>ma</b> kota'', nale¿y do³±czyæ do
wiadomo¶ci nastêpuj±c± sekwencjê bajtów:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Offset</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr><td><i>n</i></td><td><tt>0x02</tt></td><td>Opis atrybutów tekstu...</td></tr>
<tr><td><i>n</i> + 1</td><td rowspan=2><tt>0x0006</tt></td><td rowspan=2>...maj±cy 6 bajtów d³ugo¶ci</td></tr>
<tr><td><i>n</i> + 2</td></tr>
<tr bgcolor="#f0f0f0"><td><i>n</i> + 3</td><td rowspan=2><tt>0x0004</tt></td><td rowspan=2>Atrybut zaczyna siê od pozycji 4...</td></tr>
<tr bgcolor="#f0f0f0"><td><i>n</i> + 4</td></tr>
<tr bgcolor="#f0f0f0"><td><i>n</i> + 5</td><td><tt>0x01</tt></td><td>...i jest to pogrubiony tekst</tr>
<tr><td><i>n</i> + 6</td><td rowspan=2><tt>0x0006</tt></td><td rowspan=2>Atrybut zaczyna siê od pozycji 6...</td></tr>
<tr><td><i>n</i> + 7</td></tr>
<tr><td><i>n</i> + 8</td><td><tt>0x00</tt></td><td>...i jest to zwyk³y tekst</tr>
</table></center>
<p>
Serwer po otrzymaniu wiadomo¶ci odsy³a potwierdzenie, które przy okazji
mówi nam, czy wiadomo¶æ dotar³a do odbiorcy czy zosta³a zakolejkowana
z powodu nieobecno¶ci. Otrzymujemy je w postaci pakietu:
<p><p><pre>
	#define GG_SEND_MSG_ACK 0x0005
	
	struct gg_send_msg_ack {
		int status;	<i>/* stan wiadomo¶ci */</i>
		int recipient;	<i>/* numer odbiorcy */</i>
		int seq;	<i>/* numer sekwencyjny */</i>
	};
</pre></p>
Numer sekwencyjny i numer adresata s± takie same jak podczas wysy³ania,
a stan wiadomo¶ci mo¿e byæ jednym z nastêpnyj±cych:
<p>
<center><table border=1 cellspacing=0 cellpadding=2>
<tr bgcolor=silver><td><b>Etykieta</b></td><td><b>Warto¶æ</b></td><td><b>Znaczenie</b></td></tr>
<tr><td><tt>GG_ACK_DELIVERED</tt></td><td><tt>0x0002</tt></td><td>Wiadomo¶æ dostarczono</td></tr>
<tr><td><tt>GG_ACK_QUEUED</tt></td><td><tt>0x0003</tt></td><td>Wiadomo¶æ zakolejkowano</td></tr>
<tt><td><tt>GG_ACK_NOT_DELIVERED</tt></td><td><tt>0x0006</tt></td><td>Wiadomo¶ci nie dostarczono. Odpowied¼ ta wystêpuje tylko w przypadku wiadomo¶ci klasy <tt>GG_CLASS_CTCP</tt></td></tr>
</table></center>
<p>

<hr>
<h3>1.7. Otrzymywanie wiadomo¶ci</h3>
<p>
Wiadomo¶ci serwer przysy³a za pomoc± pakietu:
<p><p><pre>
	#define GG_RECV_MSG 0x000a
	
	struct gg_recv_msg {
		int sender;		<i>/* numer nadawcy */</i>
		int seq;		<i>/* numer sekwencyjny */</i>
		int time;		<i>/* czas nadania */</i>
		int class;		<i>/* klasa wiadomo¶ci */</i>
		char message[];		<i>/* tre¶æ wiadomo¶ci */</i>
	};
</pre></p>
Czas nadania jest zapisany najwyra¼niej w ilo¶ci sekund od 1 stycznie 1970r.
W przypadku pakietów ,,konferencyjnych'' na koñcu pakietu doklejona jest
struktura identyczna z <tt>gg_msg_recipients</tt> zawieraj±ca pozosta³ych
rozmówców.

<hr>
<h3>1.8. Ping, pong</h3>
<p>
Od czasu do czasu klient wysy³a pakiet do serwera, by oznajmiæ, ¿e po³±czenie
jeszcze jest utrzymywane. Je¶li serwer nie dostanie takiego pakietu w
przeci±gu 5 minut, zrywa po³±czenie. To, czy klient dostaje odpowied¼
zmienia siê z wersji na wersjê, wiêc najlepiej nie polegaæ na tym.
<p><p><pre>
	#define GG_PING 0x0008
	
	#define GG_PONG 0x0007
</pre></p>

<hr>
<h3>1.9. Roz³±czenie</h3>
<p>
Je¶li serwer zechce nas roz³±czyæ, wy¶le wcze¶niej pusty pakiet:
<p><p><pre>
	#define GG_DISCONNECTING 0x000b
</pre></p>
Ma to miejsce, gdy próbowano zbyt wiele razy po³±czyæ siê z nieprawid³owym
has³em, lub gdy równocze¶nie po³±czy siê drugi klient z tym samym numerem
(nowe po³±czenie ma wiêkszy priorytet).

<hr>
<h2>2. Us³ugi HTTP</h2>
<p>
Do zrobienia.

<hr>
<h2>3. Bezpo¶rednie po³±czenie</h2>
<p>
Do zrobienia.

<a name="ch4">
<hr>
<h2>4. Autorzy</h2>
<p>
Autorami powy¿szego opisu s±:
<ul>
<li>Wojtek Kaniewski (wojtekka/irc.pl): pierwsza wersja opisu, poprawki, utrzymanie wszystkiego w porz±dku.
<li>Robert J. Wo¼ny (speedy/atman.pl): opis nowo¶ci w protokole GG 4.6, poprawki.
<li>Tomasz Jarzynka (tomee/cpi.pl): badanie timeoutów.
<li>Adam Ludwikowski (adam.ludwikowski/wp.pl): wiele poprawek, wersje klientów, rozszerzone wiadomo¶ci, powody nieobecno¶ci.
<li>Marek Kozina (klith/hybrid.art.pl): czas otrzymania wiadomo¶ci.
<li>Rafa³ Florek (raf/regionet.regionet.pl): opis po³±czeñ konferencyjnych.
<li>Igor Popik (igipop/wsfiz.edu.pl): klasy wiadomo¶ci przy odbieraniu zakolejkowanej.
<li>Rafa³ Cyran (ajron/wp.pl): informacje o remote_port, rodzaje potwierdzeñ przy ctcp.
</ul>

<hr>
<font color=silver>
$Id$
</font>

</tr></td></table>
</center>

</body>
</html>
