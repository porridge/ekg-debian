// bezpo¶rednie po³±czenia miêdzy klientami (dcc) w ekg

obs³uga dcc nie jest jeszcze kompletna. brakuje wielu rzeczy. w chwili
obecnej mo¿na odbieraæ pliki. by w³±czyæ dcc nale¿y wpisaæ:

	set dcc 1
	set dcc_ip <adres_ip>
	reconnect

od tej chwili mo¿emy odbieraæ wysy³ane do nas pliki. je¶li kto¶ spróbuje
co¶ do nas wys³aæ, pojawi siê:

	->- ktos/123 przesy³a plik zdjecie.jpg o rozmiarze 129117
	->- Wpisz dcc get #1 by go odebraæ, lub dcc close #1 by anulowaæ

dalszych instrukcji chyba nie trzeba podawaæ. inne opcje dcc bêd±
dostêpne w ci±gu kilku najbli¿szych dni. proszê _nie_przesy³aæ_
informacji, ¿e nie dzia³a nie istniej± opcja, ani nie pytaæ siê,
kiedy bêdzie dzia³aæ.

// api kodu dcc

to jest pocz±tkowy opis pocz±tkowych stadiów kodu. wszystko mo¿e siê
zmieniæ i naprawdopodobniej spora czê¶æ ulegnie zmianie.

gadu-gadu, w przeciwieñstwie do irc, umo¿liwia po³±czenia w obie strony,
bez wzglêdu na to, który klient nadaje, a który odbiera. do tego, je¶li
obie strony wychodz± z tego samego adresu IP, serwer informuje ich o ich
adresach wewnêtrznych z tego samego LANu. mamy kilka mo¿liwych sytuacji:

a) mam publiczny lub niepubliczny adres IP i chcê wys³aæ plik do kogo¶
   z publicznym adresem -- ³±czê siê z jego klientem, przedstawiam siê,
   mówiê czego chcê i je¶li to zaakceptuje, zaczynam wysy³aæ plik. bardzo
   to przypomina zwyk³e po³±czenia dcc klientów irc.

b) mam publiczny adres IP i wys³am plik do kogo¶ za maskarad± -- wysy³am
   do niego odpowiedni pakiet ctcp (client-to-client protocol). jest to
   pakiet klasy GG_CLASS_CTCP (0x10) o tre¶ci sk³adaj±cej siê z jednego
   znaku o kodzie 0x02. druga strona, odebrawszy taki pakiet ³±czy siê
   z nami, mówi, ¿e proszono j± o po³±czenie i czeka na dalsze instrukcje.
   wtedy wysy³amy informacjê, ¿e owszem, chcemy wys³aæ plik, mówimy jaki
   i je¶li druga strona to zaakceptuje, nadajemy.

c) mam niepubliczny adres IP, tak samo jak i druga strona -- tutaj
   nawi±zanie po³±czenia jest mo¿liwe tylko i wy³±cznie, gdy oba klienty
   znajduj± siê w tej samej sieci (tj. oba ³±cz± siê z serwerem GG z tego
   samego adresu zewnêtrznego) i wygl±da to wtedy identycznie jak w punkcie
   a).

to, czy mo¿emy siê z kim¶ po³±czyæ widaæ po porcie, jaki dostajemy w
pakietach gg_notify_reply. je¶li jest mniejszy ni¿ 10, po³±czenie nie
jest mo¿liwe, a wtedy wysy³amy pakiet ctcp za pomoc± funkcji
gg_dcc_request().

ka¿de po³±czenie zwi±zanie z dcc opisywane jest przez strukturê gg_dcc.
najwa¿niejsze jest GG_SESSION_DCC_SOCKET, które odpowiada za przychodz±ce
po³±czenia. tworzymy je przez:

	struct gg_dcc *socket = gg_dcc_socket_create(uin, port);

	if (!socket)
		wykrzacz_siê("nie mogê otworzyæ socketu");

	dodaj_do_listy_przegl±danych_deskryptorów(socket);

port mo¿e wynosiæ 0, a wtedy libgadu samo we¼mie pierwszy lepszy
z brzegu. w razie powodzenia zwraca zaalokowan± strukturê gg_dcc,
której najbardziej interesuj±cym polem jest gg_dcc->port zawieraj±ce
numer przyznanego portu. je¶li funkcja zwróci NULL, patrzymy na errno.
EINVAL to niew³a¶ciwie parametry, ENOMEM brak pamiêci, a reszta
mo¿liwych b³êdów to te zwi±zane z socketami, typu EADDRINUSE gdy nie
mo¿e wolnego portu znale¼æ.

teraz wypada³oby ustawiæ zmienn± ,,gg_dcc_port'' i po³±czyæ siê z
serwerem GG, ¿eby og³osiæ swoje namiary. og³aszany adres IP bêdzie
brany z po³±czenia z serwerem.

	gg_dcc_port = socket->port;
	po³±cz_siê_z_serwerem();

w ka¿dym razie, gdy pojawi siê co¶ na deskryptorze, wywo³ujemy:

	struct gg_event *event = gg_dcc_watch_fd(socket);

	if (!event) {
		usuñ_z_listy_przegl±danych_deskryptorów(socket);
		gg_dcc_free(socket);
		wykrzacz_siê("powa¿ny b³±d"):
	}

b³±d jest zwracany tylko w naprawdê krytycznych sytuacjach, gdy
brakuje pamiêci, lub nie powiod³a siê operacja na socketach, która
nie mia³a siê nie powie¶æ (i przy okazji dalsza zabawa danym
jest kompletnie bezcelowa).

je¶li b³êdu nie bêdzie, dostajemy informacje o zdarzeniu. w przypadku
GG_SESSION_DCC_SOCKET mog± to byæ:

1) GG_EVENT_NONE -- nic ciekawego siê nie wydarzy³o.

2) GG_EVENT_DCC_ERROR -- wyst±pi³ b³±d, którego kod znajduje siê w
   event->event.dcc_error. w przypadku tego typu sesji mo¿liwy jest
   tylko GG_ERROR_DCC_HANDSHAKE, który mówi, ¿e nie uda³o siê nawi±zaæ
   po³±czenia z klientem.

3) GG_EVENT_DCC_NEW -- nowe po³±czenie od klienta. w polu
   event->event.dcc_new jest struktura gg_dcc typu GG_SESSION_DCC,
   któr± dodajemy do listy przegl±danych desktyptorów.

w ka¿dym z tych wypadków nale¿y po sprawdzeniu zdarzenia wywo³aæ funkcjê:

	gg_event_free(socket->event);

by zwolniæ pamiêæ po zdarzeniu.


gdy nadejdzie po³±czenie i dopiszemy je do listy przegl±danych deskyptorów,
musimy zwracaæ uwagê na nastêpuj±ce zdarzenia:

1) GG_EVENT_NONE -- nic siê nie zdarzy³o.

2) GG_EVENT_DCC_CLIENT_ACCEPT -- klient siê przedstawi³ i czeka na
   autoryzacjê po³±czenia. sprawdzamy gg_dcc->uin czy jest naszym numerem
   i czy gg_dcc->peer_uin jest na naszej li¶cie kontaktów i czy chcemy z
   nim nawi±zywaæ po³±czenie. je¶li nie, to po prostu usuwamy po³±czenie:

   	if (!akceptujemy_po³±czenie(klient->uin, klient->peer_uin)) {
		usuñ_z_listy_przegl±danych_deskryptorów(client);
		gg_dcc_free(klient);
	}

3) GG_EVENT_DCC_NEED_FILE_ACK -- klient chce wys³aæ nam plik. w strukturze
   gg_dcc->file_info znajduj± siê wszystkie informacje na temat pliku, jak
   jego nazwa, rozmiar, atrybuty, data i czas utworzenia itp. je¶li nie
   chcemy pliku, zamykamy po³±czenie w podobny sposób jak przy braku
   autoryzacji. libgadu jeszcze nie potrafi odpowiadaæ negatywnie na pro¶by
   po³±czeñ dcc. je¶li chcemy plik, otwieramy plik do zapisu i numer jego
   deskryptora zapisujemy do gg_dcc->file_fd. dalej libgadu zajmie siê
   transferem.

4) GG_EVENT_DCC_NEED_FILE_INFO -- wcze¶niej poprosili¶my drug± stronê by
   siê z nami po³±czy³a, bo jest za maskarad±, a my chcemy wys³aæ plik.
   w tym wypadku mo¿emy albo sami wype³niæ strukturê gg_dcc->file_info,
   któr± biblioteka wy¶le drugiej stronie, albo skorzystaæ z funkcji
   gg_dcc_fill_file_info().

   	if (gg_dcc_fill_file_info(klient, nazwa_pliku)) {
		wykrzacz_siê("nie mogê otworzyæ pliku");
		usuñ_z_listy_przegl±danych_deskryptorów(klient);
		gg_dcc_free(klient);
	}

5) GG_EVENT_DCC_DONE -- zakoñczono transfer, mo¿na ju¿ nie patrzeæ na
   deskryptor i zwolniæ pamiêæ po po³±czeniu.

6) GG_EVENT_DCC_ERROR -- b³±d. mo¿liwy kod b³êdu to GG_ERROR_DCC_HANDSHAKE
   gdy nie powiod³o siê ustanowienie po³±czenia z klientem, GG_ERROR_DCC_NET
   kiedy nie uda³o siê wys³ac lub odczytaæ czego¶ z socketa, GG_ERROR_DCC_FILE
   gdy nie mo¿na by³o odczytaæ albo zapisaæ do pliku, GG_ERROR_DCC_EOF gdy
   plik lub po³±czenie zbyt wcze¶nie siê skoñczy.

tutaj równie¿ nale¿y pamiêtaæ o wywo³ywaniu gg_event_free().


je¶li chcemy sami wys³aæ plik, sprawdzamy najpierw, czy druga strona
mo¿e przyj±æ po³±czenie, patrz±c na jej port. je¶li powy¿ej 10, mo¿emy
¶mia³o wywo³aæ funkcjê:

	struct gg_dcc *klient = gg_dcc_send_file(adres_ip, port, nasz_uin, jego_uin);

	if (!klient)
		wykrzacz_siê("nie mo¿na ustanowiæ po³±czenia");

zaraz potem mo¿emy wywo³aæ funkcjê gg_dcc_fill_file_info() by uzupe³niæ
informacjê o pliku...

	gg_dcc_fill_file_info(klient, nazwa_pliku);

...ale je¶li tego nie zrobimy teraz, biblioteka poprosi nas o to
w odpowiedniej za pomoc± zdarzenia GG_EVENT_DCC_NEED_FILE_INFO.

je¶li port jest podejrzanie niski, znaczy ¿e po³±czenie jest niemo¿liwe
i wtedy wywo³ujemy funkcjê:

	gg_dcc_request(sesja_gg, jego_uin);

gdzie sesja_gg to nasza sesja GG (jako¶ musimy wys³aæ wiadomo¶æ),
a jego_uin to numer drugiej strony. spowoduje ona, ¿e druga strona
spróbuje siê z nami po³±czyæ, je¶li ma tak± mo¿liwo¶æ.






// $Id$
