
                             Protokó³ Gadu-Gadu

                   (c) Copyright 2001-2002 by [1]Autorzy
     _________________________________________________________________

0. Informacje wstêpne

   Opis protoko³u u¿ywanego przez Gadu-gadu bazuje na do¶wiadczeniach
   przeprowadzonych przez autorów oraz informacjach nadsy³anych przez
   u¿ytkowników. ¯aden klient Gadu-gadu nie zosta³ skrzywdzony podczas
   badañ. Reverse-engineering opiera³ siê g³ównie na analizie pakietów
   wysy³anych miêdzy klientem a serwerem.
     _________________________________________________________________

1. Protokó³ Gadu-gadu

  1.1. Format pakietów

   Podobnie jak coraz wiêksza ilo¶æ komunikatorów, Gadu-gadu korzysta z
   protoko³u TCP/IP. Ka¿dy pakiet zawiera na pocz±tku dwa sta³e pola:

        struct gg_header {
                int type;               /* typ pakietu */
                int length;             /* d³ugo¶æ reszty pakietu */
        };

   Wszystkie zmienne liczbowe s± zgodne z kolejno¶ci± bajtów maszyn
   Intela, czyli Little-Endian.

   Przy opisie struktur, za³o¿ono, ¿e char ma rozmiar 1 bajtu, short 2
   bajtów, int 4 bajtów. U¿ywaj±c innych architektur ni¿ i386 nale¿y
   zwróciæ szczególn± uwagê na rozmiar typów zmiennych i kolejno¶æ
   znaków.

   Pola, który znaczenie jest nieznane, lub nie do koñca jasne, oznaczono
   przedrostkiem unknown.
     _________________________________________________________________

  1.2. Zanim siê po³±czymy

   ¯eby wiedzieæ, z jakim serwerem mamy siê po³±czyæ, nale¿y poudawaæ
   przez chwilê przegl±darkê WWW i po³±czyæ siê z hostem
   appmsg.gadu-gadu.pl.

        GET /appsvc/appmsg.asp?fmnumber=NumerGG HTTP/1.0
        Host: appmsg.gadu-gadu.pl
        User-Agent: Mozilla/4.7 [en] (Win98; I)
        Pragma: no-cache

   Oryginalny klient mo¿e wys³aæ jeden z podanych identyfikatorów
   przegl±darki:

        Mozilla/4.04 [en] (Win95; I ;Nav)
        Mozilla/4.7 [en] (Win98; I)
        Mozilla/4.0 (compatible; MSIE 5.0; Windows NT; DigExt)
        Mozilla/4.0 (compatible; MSIE 5.0; Windows NT)
        Mozilla/4.0 (compatible; MSIE 5.0; Windows 98; DigExt)
        Mozilla/4.0 (compatible; MSIE 5.0; Windows 98)

   Nowsze wersje klienta do zapytania dodaj± równie¿ pole version=x.y
   opisuj±ce, z jakim klientem serwer ma do czynienia. Jednak ze wzglêdu
   na mo¿liwe ró¿nice w protokole i inne traktowanie ró¿nych wersji
   klienta, lepiej pomijaæ ten parametr. Na postawione wcze¶niej
   zapytanie, serwer powinien odpowiedzieæ:

        HTTP/1.0 200 OK

        124 1 0 217.17.33.21:8074 0.0.0.0

   nie mam pojêcia ;) wygl±da na to, ¿e ca³y g*du-g*du jest przemy¶lany i
   w przysz³o¶ci bêdzie mo¿na u¿ywaæ ró¿nych serwerów do ró¿nych rzeczy,
   typu szukanie, obs³uga klientów itd. póki co, ³±czyæ siê trzeba na
   pierwszy adres (tak, ten z portem). Je¿eli po³±czenie z portem 8074
   nie wyjdzie z jaki¶ specyficznych powodów - mo¿na siê ³±czyæ na port
   443.
     _________________________________________________________________

  1.3. Logowanie siê

   po po³±czeniu siê portem serwera g*du-g*du, dostajemy pakiet typu
   0x0001, który na potrzeby tego dokumentu nazwiemy:

        #define GG_WELCOME 0x0001

   reszta pakietu zawiera liczbê, na podstawie której liczony jest hash z
   has³a klienta:

        struct gg_welcome {
                int key;                /* klucz szyfrowania has³a */
        };

   kiedy mamy ju¿ t± warto¶æ mo¿emy odes³aæ pakiet logowania

        #define GG_LOGIN 0x000c

   musimy podaæ kilka informacji:

        struct gg_login {
                int uin;                /* twój numerek */
                int hash;               /* hash has³a */
                int status;             /* status na dzieñ dobry */
                int version;            /* wersja klienta */
                int local_ip;           /* mój adres ip */
                short local_port;       /* port, na którym s³ucham */
        };

   jak obliczyæ hash has³a? hmm... nic prostszego. do ka¿dej literki
   has³a dodaje siê jedynkê, mno¿y wszystko razem, a potem przez liczbê
   podan± przez serwer.

        for (hash = 1; *passwd; passwd++)
                hash *= (*passwd) + 1;

   zrozumia³e, racja? liczba oznaczaj±ca wersjê mo¿e byæ jedn± z
   poni¿szych:

        0x15 - 4.8.9 b1, 4.8.9 b2, 4.8.9 b3
        0x14 - 4.8.3, 4.8.1
        0x11 - 4.6.10, 4.6.1
        0x10 - 4.5.22, 4.5.21, 4.5.19, 4.5.17, 4.5.15
        0x0f - 4.5.12
        0x0b - 4.0.30, 4.0.29, 4.0.28, 4.0.25

   oczywi¶cie nie s± to wszystkie mo¿liwe wersje klientów, lecz te, które
   uda³o siê sprawdziæ. najbezpieczniej bêdzie przedstawiaæ siê jako ta
   wersja, której ficzerów u¿ywamy. wiadomo, ¿e 4.0.x nie obs³ugiwa³y
   trybu ukrytego, ani tylko dla znajomych itd.

   je¶li wszystko siê powiedzie, dostaniemy w odpowiedzi pakiet typu

        #define GG_LOGIN_OK 0x0003

   z polem header->length = 0, lub pakiet

        #define GG_LOGIN_FAILED 0x0009
     _________________________________________________________________

  1.4. Zmiana stanu

   g*du-g*du przewiduje trzy stany klienta, które zmieniamy pakietem

        #define GG_NEW_STATUS 0x0002

        #define GG_STATUS_NOT_AVAIL 0x0001      /* roz³±czony */
        #define GG_STATUS_AVAIL 0x0002          /* dostêpny */
        #define GG_STATUS_BUSY 0x0003           /* zajêty */
        #define GG_STATUS_BUSY_DESCR 0x0004     /* zajêty z opisem */
        #define GG_STATUS_INVISIBLE 0x0014      /* niewidoczny */

        #define GG_STATUS_FRIENDS_MASK 0x8000   /* tylko dla przyjació³ */

        struct gg_new_status {
                int status;                     /* na jaki zmieniæ? */
                char description[];             /* opis, nie musi wyst±piæ */
        }

   nale¿y pamiêtaæ, ¿eby przed roz³±czeniem siê z serwerem nale¿y zmieniæ
   stan na GG_STATUS_NOT_AVAIL. je¶li ma byæ widoczny tylko dla
   przyjació³, nale¿y dodaæ GG_STATUS_FRIENDS do normalnej warto¶ci
   stanu. je¶li wybieramy stan z opisem, nale¿y dokleiæ do struktury ci±g
   znaków niezakoñczony zerem.
     _________________________________________________________________

  1.5. Ludzie przychodz±, ludzie odchodz±

   zaraz po zalogowaniu mo¿emy wys³aæ serwerowi listê ludzików w naszej
   li¶cie kontaktów, ¿eby dowiedzieæ siê, czy s± w tej chwili dostêpni.
   pakiet zawiera dowoln± ilo¶æ struktur gg_notify:

        #define GG_NOTIFY 0x0010

        struct gg_notify {
                int uin;                /* numerek danej osoby */
                char dunno1;            /* == 3 */
        };

   je¶li kto¶ jest, serwer odpowie pakietem zawieraj±cym jedn± lub wiêcej
   struktur gg_notify_reply:

        #define GG_NOTIFY_REPLY 0x000c  /* tak, to samo co GG_LOGIN */

        struct gg_notify_reply {
                int uin;                /* numerek */
                int status;             /* status danej osoby */
                int remote_ip;          /* adres ip delikwenta */
                short remote_port;      /* port, na którym s³ucha klient */
                int version;            /* wersja klienta */
                short dunno1;           /* znowu port? */
                char description[];     /* opis, nie musi wyst±piæ */
        };

   wiêkszo¶æ pól powinna byæ zrozumia³a. remote_port poza zwyk³ym portem
   mo¿e przyjmowaæ równie¿ poni¿sze warto¶ci:

        0 - klient nie obs³uguje bezpo¶rednich po³±czeñ,
        1 - klient jest za NAT,
        2 - klient nie ma nas w swojej li¶cie kontaktów.

   zdarzaj± siê te¿ inne ,,nietypowe'' warto¶ci, ale ich znaczenie nie
   jest jeszcze do koñca znane.

   je¶li dany klient jest w stanie z podanym opisem, najpierw dostaniemy
   informacjê osobnym pakietem o nim, pó¼niej paczkê struktur
   gg_notify_reply z lud¼mi, którzy nie maj± ustawionych opisów.

   ¿eby dodaæ kogo¶ do listy w trakcie pracy, trzeba wys³aæ ni¿ej opisany
   pakiet. jego format jest identyczny jak przy GG_NOTIFY.

        #define GG_ADD 0x000d

        struct gg_add {
                int uin;                /* numerek */
                char dunno1;            /* == 3 */
        };

   je¶li kto¶ opu¶ci g*du-g*du lub zmieni stan, otrzymamy pakiet

        #define GG_STATUS 0x0002

        struct gg_status {
                int uin;                /* numerek */
                int status;             /* nowy stan */
        };
     _________________________________________________________________

  1.6. Wysy³anie wiadomo¶ci

   przejd¼my do sedna sprawy ;)

        #define GG_SEND_MSG 0x000b

        #define GG_CLASS_QUEUED 0x0001  /* tylko przy odbieraniu */
        #define GG_CLASS_MSG 0x0004
        #define GG_CLASS_CHAT 0x0008
        #define GG_CLASS_CTCP 0x0010    /* dla klienta GG */
        #define GG_CLASS_UNKNOWN_1 0x0020

        struct gg_send_msg {
                int recipient;
                int seq;
                int class;
                char message[];
        };

   wiadomo, odbiorca. numer sekwencyjny, który wykorzystujemy potem do
   potwierdzenia. nie wykluczone, ¿e w jakis sposób odró¿nia siê ró¿ne
   rozmowy za pomoc± czê¶ci bajtów, ale raczej nie ma znaczenia. klasa
   wiadomo¶ci pozwala odró¿niæ, czy wiadomo¶æ ma siê pokazaæ w osobym
   okienku czy jako kolejna linijka w okienku rozmowy. wygl±da na to, ¿e
   to jaka¶ bitmapa, wiêc najlepiej olaæ inne bity ni¿ 0x0e. (czasem
   klienty wysy³aj± 0x04, czasem 0x24 -- widocznie 0x20 to te¿ jaka¶
   flaga). je¶li odbiorca bêdzie niedostêpny podczas wysy³ania
   wiadomo¶ci, odbierze j± z zaznaczonym bitem GG_CLASS_QUEUED. wiadomo¶æ
   nie powinna przekraczaæ 2000 znaków.

   oryginalny klient wysy³aj±c wiadomo¶æ do kilku u¿ytkowników, wysy³a po
   prostu kilka takich samych pakietów z ró¿nymi numerkami odbiorców. nie
   ma osobnego pakietu do tego. natomiast je¶li chodzi o
   ,,konferencyjnê'' do pakietu doklejana jest za ,,char message[];''
   nastêpuj±ca struktura:

        struct gg_send_recipients {
                char flag;              /* == 1 */
                int count;              /* ilo¶æ odbiorców */
                int recipients[];       /* tablica odbiorców */
        };

   na przyk³ad, by wys³aæ do trzech ludzi, nale¿y wys³aæ pakiet:

        - -- --- --+--+--+--+--+--+--+-----------+-----------+
          tre¶æ    |\0|\1|    0x02   |    uin1   |   uin2    |
        - -- -- ---+--+--+--+--+--+--+--+--+--+--+--+--+--+--+

   serwer po otrzymaniu wiadomo¶ci odsy³a informacjê o tym. przy okazji
   mówi, czy wiadomo¶æ dotar³a do odbiorcy (status == GG_ACK_DELIVERED),
   czy mo¿e jest offline i zosta³a zakolejkowana (GG_ACK_QUEUED). je¶li
   by³a wysy³ana wiadomo¶æ do wiadomo¶ci klienta (GG_MSG_CLASS_CTCP),
   przy nieobecno¶ci odbiorcy, zostanie zwrócone GG_ACK_NOT_DELIVERED.

        #define GG_SEND_MSG_ACK 0x0005

        #define GG_ACK_DELIVERED 0x0002
        #define GG_ACK_QUEUED 0x0003
        #define GG_ACK_NOT_DELIVERED 0x0006

        struct gg_send_msg_ack {
                int status;
                int recipient;
                int seq;
        };

   numer sekwencyjny i adresat ten sam, co przy wysy³aniu.
     _________________________________________________________________

  1.7. Otrzymywanie wiadomo¶ci

   zbyt wiele wyja¶nieñ chyba nie trzeba. wiadomo od kogo. drugie pole to
   najprawdopodobniej jaki¶ numerek sekwencyjny. trzecie oznacza czas
   nadania wiadomo¶ci. klasa wiadomo¶ci taka sama jak przy wysy³aniu:

        #define GG_RECV_MSG 0x000a

        struct gg_recv_msg {
                int sender;
                int seq;
                int time;
                int class;
                char message[];
        };

   w przypadku pakietów ,,konferencyjnych'' na koncu pakietu doklejona
   jest struktura identyczna ze struct gg_send_recipients zawieraj±ca
   pozosta³ych rozmówców.
     _________________________________________________________________

  1.8. Ping/pong

   od czasu do czasu klient wysy³a pakiet a'la ping do serwera i dostaje
   pust± odpowied¼. o ile dobrze pamiêtam, serwer roz³±cza siê po up³ywie
   5 minut od otrzymania ostatniej informacji.

        #define GG_PING 0x0008

        /* nie ma niczego */

        #define GG_PONG 0x0007

        /* nie ma niczego */
     _________________________________________________________________

  1.9. Roz³±czenie

   je¶li serwer zechce nas roz³±czyæ, wy¶le wcze¶niej pusty pakiet:

        #define GG_DISCONNECTING 0x000b

        /* nie ma niczego */
     _________________________________________________________________

2. Us³ugi HTTP

   Do zrobienia.
     _________________________________________________________________

3. Bezpo¶renie po³±czenie

   Do zrobienia.
     _________________________________________________________________

4. Autorzy

   Autorami powy¿szego opisu s±:
     * Wojtek Kaniewski (wojtekka/irc.pl): pierwsza wersja opisu,
       poprawki.
     * Robert J. Wo¼ny (speedy/atman.pl): opis nowo¶ci w protokole GG
       4.6, poprawki.
     * Tomasz Jarzynka (tomee/cpi.pl): badanie timeoutów.
     * Adam Ludwikowski (adam.ludwikowski/wp.pl): wiele poprawek, wersje
       klientów, rozszerzone wiadomo¶ci, powody nieobecno¶ci.
     * Marek Kozina (klith/hybrid.art.pl): czas otrzymania wiadomo¶ci.
     * Rafa³ Florek (raf/regionet.regionet.pl): opis po³±czeñ
       konferencyjnych.
     * Igor Popik (igipop/wsfiz.edu.pl): klasy wiadomo¶ci przy odbieraniu
       zakolejkowanej.
     * Rafa³ Cyran (ajron/wp.pl): informacje o remote_port, rodzaje
       potwierdzeñ przy ctcp.
     _________________________________________________________________

   $Id$

References

   1. file://localhost/home/wojtekka/src/ekg/docs/protocol.html#ch4
