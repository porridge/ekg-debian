diff -r -u2 ekg-20020320/src/commands.c my_ekg/src/commands.c
--- ekg-20020320/src/commands.c	Wed Mar 20 10:52:26 2002
+++ my_ekg/src/commands.c	Sat Mar 23 00:40:11 2002
@@ -307,5 +307,10 @@
 	char *params = NULL;
 	int word = 0, i, abbrs = 0;
-	CPFunction *func = empty_generator;
+	/*
+	 * jezeli standardowo bedzie ustawione na known_uin, to ulatwi to
+	 * poslugiwanie sie aliasami, tzn tak mysle, mi to jest strasznie na reke
+	 * i za kazdym razem zmieniam ;)
+	 */
+	CPFunction *func = known_uin_generator;
 
 	if (start) {
@@ -1049,6 +1054,6 @@
 {
 	struct list *l;
-	int count = 0, show_all = 1, show_busy = 0, show_active = 0, show_inactive = 0, j, page_wait = 0;
-	char *tmp, **argv = NULL;
+	int count = 0, show_all = 1, show_busy = 0, show_active = 0, show_inactive = 0, show_invisible = 0, j, page_wait = 0;
+	char *show = NULL, *tmp, **argv = NULL;
 
 	if (params[0] && *params[0] != '-') {
@@ -1113,5 +1118,5 @@
 	}
 
-	/* list --active | --busy | --inactive [--wait] */
+	/* list --active | --busy | --inactive | -invisible [--wait] */
 	for (j = 0; params[j]; j++) {
       		if ((argv = array_make(params[j], " \t", 0, 1, 1))) {
@@ -1132,4 +1137,9 @@
 					show_inactive = 1;
 				}
+
+				if (match_arg(argv[i], 'I', "invisible")) {
+					show_all = 0;
+					show_invisible = 1;
+				}
 				
 				if (match_arg(argv[i], 'b', "busy")) {
@@ -1137,4 +1147,16 @@
 					show_busy = 1;
 				}
+
+				/*
+				 * takie show bardzo przydatne zeby sprawdzic status konkretnej
+				 * osoby natychmiast, bez przeszukiwania calej listy
+				 * nie wymyslilem jakby ambitniej to napisac
+				 */
+				if (match_arg(argv[i], 's', "show")) {
+					if (params[j+1]) {
+						show_all = 0;
+						show = strdup(params[++j]);
+					}
+				}
 			}
 			array_free(argv);
@@ -1146,4 +1168,7 @@
 		struct in_addr in;
 
+		if (show && strcasecmp(format_user(u->uin), show))
+			continue;
+		
 		tmp = "list_unknown";
 		switch (u->status) {
@@ -1163,4 +1188,7 @@
 				tmp = "list_not_avail_descr";
 				break;
+			case GG_STATUS_INVISIBLE:
+				tmp = "list_invisible";
+				break;
 			
 		}
@@ -1168,7 +1196,7 @@
 		in.s_addr = u->ip.s_addr;
 
-		if (show_all || (show_busy && (u->status == GG_STATUS_BUSY || u->status == GG_STATUS_BUSY_DESCR)) || (show_active && u->status == GG_STATUS_AVAIL) || (show_inactive && (u->status == GG_STATUS_NOT_AVAIL || u->status == GG_STATUS_NOT_AVAIL_DESCR))) {
+		if (show || show_all || (show_invisible && u->status == GG_STATUS_INVISIBLE) || (show_busy && (u->status == GG_STATUS_BUSY || u->status == GG_STATUS_BUSY_DESCR)) || (show_active && u->status == GG_STATUS_AVAIL) || (show_inactive && (u->status == GG_STATUS_NOT_AVAIL || u->status == GG_STATUS_NOT_AVAIL_DESCR))) {
 			my_printf(tmp, format_user(u->uin), inet_ntoa(in), itoa(u->port), u->descr);
-			if ((++count % (screen_lines - 1)) == 0) {
+			if ((++count % (screen_lines - 1)) == 0 && page_wait) {
 				char *foo = readline("-- Wci¶nij Enter by kontynuowaæ. --");
 				free(foo);
@@ -1176,4 +1204,7 @@
 		}
 	}
+
+	if (show)
+		free(show);
 
 	if (!count && show_all)
diff -r -u2 ekg-20020320/src/events.c my_ekg/src/events.c
--- ekg-20020320/src/events.c	Mon Mar 18 23:34:07 2002
+++ my_ekg/src/events.c	Sat Mar 23 00:31:45 2002
@@ -266,28 +266,63 @@
 
 	while (n->uin) {
-		if (ignored_check(n->uin)) {
+		/*
+		 * uwazam, ze jezeli kogos nie mamy na liscie kontaktow to nie ma sensu
+		 * sprawdzac czy zmienil status czy nie, oczywiscie ostatnie zdanie
+		 * nalezy do Ciebie
+		 */
+		if (ignored_check(n->uin) || !(u = userlist_find(n->uin, NULL))) {
 			n++;
 			continue;
 		}
 
-		if ((u = userlist_find(n->uin, NULL))) {
-			u->status = n->status;
-			u->ip.s_addr = n->remote_ip;
-			u->port = n->remote_port;
+		if (n->status == GG_STATUS_NOT_AVAIL)
+			n->status = GG_STATUS_INVISIBLE;
+
+		/*
+		 * jedyny wyjatek do tego, ze port nie bedzie sprawdzany
+		 */
+
+		if (n->status == GG_STATUS_BUSY_DESCR) {
+				check_event(EVENT_AWAY, u->uin);
 			free(u->descr);
-			u->descr = NULL;
+			u->descr = strdup(e->event.notify_descr.descr);
+			cp_to_iso(u->descr);
+			my_printf("status_busy_descr", format_user(n->uin), u->descr);
 		}
-		if (n->status == GG_STATUS_AVAIL) {
+		
+		if (n->status == u->status && n->remote_port == u->port) {
+			n++;
+			continue;
+		}
+		
+		u->status = n->status;
+		u->port = n->remote_port;
+		u->ip.s_addr = n->remote_ip;
+
+		/*
+		 * to sie zmienia wtedy gdy ktos lokalnie zmienil status, czyli
+		 * z aktywnego na jakis aktywny, lub przy naszym polaczeniu zaraz
+		 * po wyslaniu userlisty do serwera. jezeli ktos rozlaczyl sie z serwerem
+		 * to zostanie wywolane handle_status, jezeli sie dopiero co polaczyl
+		 * to tak samo handle_status, dzieki temu mozemy byc na czasie czy
+		 * ktos sie nie zrobil invisible
+		 */
+		if (n->status == GG_STATUS_AVAIL) 
+		{
+				check_event(EVENT_AVAIL, u->uin);
 			my_printf("status_avail", format_user(n->uin));
-			if (u && config_completion_notify)
+
+			if (config_completion_notify)
 				add_send_nick(u->display);
 			if (config_beep && config_beep_notify)
 				my_puts("\007");
-		} else if (n->status == GG_STATUS_BUSY) {
+		} else if (n->status == GG_STATUS_BUSY) 
+		{
+				check_event(EVENT_AWAY, n->uin);
 			my_printf("status_busy", format_user(n->uin));
-		} else if (n->status == GG_STATUS_BUSY_DESCR) {
-			u->descr = strdup(e->event.notify_descr.descr);
-			cp_to_iso(u->descr);
-			my_printf("status_busy_descr", format_user(n->uin), u->descr);
+		} else if (n->status == GG_STATUS_INVISIBLE && u->status != GG_STATUS_INVISIBLE) 
+		{
+			my_printf("status_invisible", format_user(u->uin));
+			u->status = GG_STATUS_INVISIBLE;
 		}
 		
@@ -331,5 +366,6 @@
 
 	if (config_display_notify) {
-		if (e->event.status.status == GG_STATUS_AVAIL && u->status != GG_STATUS_AVAIL) {
+		if (e->event.status.status == GG_STATUS_AVAIL && u->status != GG_STATUS_AVAIL) 
+		{
 		    	check_event(EVENT_AVAIL, e->event.status.uin);
 			if (config_completion_notify)
@@ -346,5 +382,5 @@
 		    	check_event(EVENT_AWAY, e->event.status.uin);
 			my_printf("status_busy_descr", format_user(e->event.status.uin), u->descr);
-		} else if (e->event.status.status == GG_STATUS_NOT_AVAIL && u->status != GG_STATUS_NOT_AVAIL)
+		} else if (e->event.status.status == GG_STATUS_NOT_AVAIL)
 		{
 		    	check_event(EVENT_NOT_AVAIL, e->event.status.uin);
diff -r -u2 ekg-20020320/src/themes.c my_ekg/src/themes.c
--- ekg-20020320/src/themes.c	Sat Mar  9 22:39:22 2002
+++ my_ekg/src/themes.c	Fri Mar 22 23:35:30 2002
@@ -507,4 +507,5 @@
 	add_format("list_not_avail", "%> %1 %r(niedostêpny)%n\n", 1);
 	add_format("list_not_avail_descr", "%> %1 %r(niedostêpny: %n%4%r)%n\n", 1);
+	add_format("list_invisible", "%> %1 %c(niewidoczny) %b%2:%3%n\n", 1);
 	add_format("list_unknown", "%> %1\n", 1);
 	add_format("saved", "%> Zapisano ustawienia\n", 1);
@@ -530,4 +531,5 @@
 	add_format("status_not_avail", "%> %1 jest niedostêpny %c(%C%#%c)%n\n", 1);
 	add_format("status_not_avail_descr", "%> %1 jest niedostêpny: %2 %c(%C%#%c)%n\n", 1);
+	add_format("status_invisible", "%> %1 jest niewidoczny %c(%C%#%c)%n\n", 1);
 	add_format("conn_broken", "%! Serwer zerwa³ po³±czenie: %1 %c(%C%#%c)%n\n", 1);
 	add_format("auto_away", "%> Automagicznie zmieniono stan na zajêty po %1 nieaktywno¶ci %c(%C%#%c)%n\n", 1);
